package com.endsec.services

import cats.effect.*
import cats.syntax.all.*
import fs2.Stream
import org.typelevel.log4cats.Logger
import org.typelevel.log4cats.slf4j.Slf4jLogger

import com.endsec.domain.*
import com.endsec.repositories.SecurityEventRepository
import com.endsec.utils.{ProcessUtils, SystemInfo}

import java.time.Instant
import java.util.UUID
import scala.concurrent.duration.*

/** Service for scanning and detecting system vulnerabilities */
trait VulnerabilityScanService[F[_]]:
  def scanSystem(): F[ScanResult[VulnerabilityDetection]]
  def scanPackage(packageName: String): F[List[VulnerabilityDetection]]
  def scanOpenPorts(): F[List[VulnerabilityDetection]]
  def scanKernelVulnerabilities(): F[List[VulnerabilityDetection]]

object VulnerabilityScanService:
  def make[F[_]: Async: Logger](
                                 repository: SecurityEventRepository[F]
                               ): F[VulnerabilityScanService[F]] =
    SystemInfo.getHostInfo[F].map { hostInfo =>
      new VulnerabilityScanServiceImpl[F](repository, hostInfo)
    }

private class VulnerabilityScanServiceImpl[F[_]: Async: Logger](
                                                                 repository: SecurityEventRepository[F],
                                                                 hostInfo: HostInfo
                                                               ) extends VulnerabilityScanService[F]:
  private implicit val logger: Logger[F] = Slf4jLogger.getLogger[F]

  // Known vulnerabilities database (in a real app would connect to CVE database)
  private val knownVulnerabilities: Map[String, (String, Severity, String)] = Map(
    "OpenSSL 1.0.1" -> ("CVE-2014-0160", Severity.Critical, "Heartbleed vulnerability"),
    "Log4j 2.14.0" -> ("CVE-2021-44228", Severity.Critical, "Log4Shell vulnerability"),
    "Windows SMB 1.0" -> ("CVE-2017-0144", Severity.Critical, "EternalBlue vulnerability"),
    "Bash 4.3" -> ("CVE-2014-6271", Severity.High, "Shellshock vulnerability"),
    "Apache Struts 2.3.5" -> ("CVE-2017-5638", Severity.Critical, "Remote code execution vulnerability")
  )

  def scanSystem(): F[ScanResult[VulnerabilityDetection]] =
    val scanId = UUID.randomUUID()
    val startTime = Instant.now()

    for
      _ <- Logger[F].info(s"Starting vulnerability scan with ID: $scanId")
      packageVulns <- scanPackage("*")
      portVulns <- scanOpenPorts()
      kernelVulns <- scanKernelVulnerabilities()
      allVulns = packageVulns ++ portVulns ++ kernelVulns
      _ <- allVulns.traverse(vuln => repository.save(vuln))
      _ <- Logger[F].info(s"Vulnerability scan completed. Found ${allVulns.size} vulnerabilities.")
      endTime = Instant.now()
    yield ScanResult(
      scanId = scanId,
      scanStartTime = startTime,
      scanEndTime = endTime,
      scanType = ScanType.VulnerabilityScan,
      events = allVulns,
      hostInfo = hostInfo
    )

  def scanPackage(packageName: String): F[List[VulnerabilityDetection]] =
    for
      _ <- Logger[F].info(s"Scanning packages matching: $packageName")
      // Simulate getting installed packages
      installedPackages <- if hostInfo.os.toLowerCase.contains("windows") then
        getWindowsInstalledPackages
      else
        getLinuxInstalledPackages
      vulnerabilities <- installedPackages.flatTraverse { case (pkg, version) =>
        checkPackageVulnerability(pkg, version)
      }
    yield vulnerabilities

  def scanOpenPorts(): F[List[VulnerabilityDetection]] =
    for
      _ <- Logger[F].info("Scanning for open ports with known vulnerabilities")
      // Simulating netstat/ss command to get open ports
      openPortsResult <- ProcessUtils.exec[F](
        if hostInfo.os.toLowerCase.contains("windows") then
          List("netstat", "-ano")
        else
          List("ss", "-tuln")
      )
      vulnerabilities <- analyzeOpenPorts(openPortsResult)
    yield vulnerabilities

  def scanKernelVulnerabilities(): F[List[VulnerabilityDetection]] =
    for
      _ <- Logger[F].info("Scanning kernel for vulnerabilities")
      kernelVersion <- ProcessUtils.exec[F](
        if hostInfo.os.toLowerCase.contains("windows") then
          List("systeminfo")
        else
          List("uname", "-r")
      )
      vulnerabilities <- analyzeKernelVulnerabilities(kernelVersion)
    yield vulnerabilities

  private def getWindowsInstalledPackages: F[List[(String, String)]] =
    // Simulate getting installed software on Windows
    val simulatedPackages = List(
      ("OpenSSL", "1.0.1"),
      ("Java Runtime", "8u202"),
      ("Windows Defender", "4.18.2104.14"),
      ("Microsoft Office", "16.0.14131.20320")
    )
    simulatedPackages.pure[F]

  private def getLinuxInstalledPackages: F[List[(String, String)]] =
    // Simulate getting installed packages on Linux
    val simulatedPackages = List(
      ("openssl", "1.1.1f"),
      ("bash", "5.0.17"),
      ("openssh-server", "8.2p1"),
      ("log4j-core", "2.14.0")
    )
    simulatedPackages.pure[F]

  private def checkPackageVulnerability(pkg: String, version: String): F[List[VulnerabilityDetection]] =
    // Check if the package+version is in our known vulnerabilities database
    val matches = knownVulnerabilities.keys.filter { key =>
      key.toLowerCase.contains(pkg.toLowerCase) && key.contains(version)
    }.toList

    matches.traverse { key =>
      val (cveId, severity, details) = knownVulnerabilities(key)
      val vuln = VulnerabilityDetection(
        severity = severity,
        source = "PackageScanner",
        details = details,
        affectedComponent = s"$pkg $version",
        cveId = Some(cveId),
        remediation = Some(s"Update $pkg to latest version")
      )
      Logger[F].warn(s"Vulnerability found in $pkg $version: $cveId - $details") *>
        vuln.pure[F]
    }

  private def analyzeOpenPorts(portsOutput: String): F[List[VulnerabilityDetection]] =
    // For demonstration, we'll simulate finding some vulnerable open ports
    val vulnerablePortServices = Map(
      "3389" -> ("Remote Desktop Protocol", Severity.High, "Exposed RDP service", "CVE-2019-0708"),
      "445" -> ("SMB", Severity.Critical, "Exposed SMB service", "CVE-2017-0144"),
      "21" -> ("FTP", Severity.Medium, "Plain text FTP protocol", "CVE-2019-5736")
    )

    val detectedVulnerablePorts = vulnerablePortServices.keys
      .filter(port => portsOutput.contains(s":$port ") || portsOutput.contains(s" $port "))
      .toList

    detectedVulnerablePorts.traverse { port =>
      val (service, severity, details, cveId) = vulnerablePortServices(port)
      val vuln = VulnerabilityDetection(
        severity = severity,
        source = "PortScanner",
        details = details,
        affectedComponent = s"$service on port $port",
        cveId = Some(cveId),
        remediation = Some(s"Close port $port or restrict access")
      )
      Logger[F].warn(s"Vulnerable service found: $service on port $port - $details") *>
        vuln.pure[F]
    }

  private def analyzeKernelVulnerabilities(kernelInfo: String): F[List[VulnerabilityDetection]] =
    // For demonstration, simulate some kernel vulnerabilities based on version
    val vulnerableKernels = Map(
      "Linux 4.4" -> ("CVE-2019-11815", Severity.High, "Race condition in rds_tcp_kill_sock"),
      "Linux 5.0.0" -> ("CVE-2019-11810", Severity.Critical, "Stack buffer overflow in TCP implementation"),
      "Windows Server 2012" -> ("CVE-2020-0796", Severity.Critical, "SMBv3 compression vulnerability"),
      "Windows 10 1909" -> ("CVE-2021-24086", Severity.High, "Windows TCP/IP Remote Code Execution Vulnerability")
    )

    val detectedVulnerableKernels = vulnerableKernels.keys
      .filter(kernel => kernelInfo.contains(kernel))
      .toList

    detectedVulnerableKernels.traverse { kernel =>
      val (cveId, severity, details) = vulnerableKernels(kernel)
      val vuln = VulnerabilityDetection(
        severity = severity,
        source = "KernelScanner",
        details = details,
        affectedComponent = kernel,
        cveId = Some(cveId),
        remediation = Some("Apply latest security patches to the kernel")
      )
      Logger[F].warn(s"Kernel vulnerability found: $kernel - $cveId - $details") *>
        vuln.pure[F]
    }